// This is automatically generated by the Tiger compiler.
// Do NOT modify!

// Control-flow Graph

// structures
struct QuickSort
{
	struct QuickSort_vtable *vptr;
	int isObjOrArray;
	unsigned length;
	void * forwarding;
};
struct QS
{
	struct QS_vtable *vptr;
	int isObjOrArray;
	unsigned length;
	void * forwarding;
	int * number;
	int size;
};
// vtables structures
struct QuickSort_vtable
{
	char * QuickSort_gc_map;
};

struct QS_vtable
{
	char * QS_gc_map;
	int (*QS_Start)();
	int (*QS_Sort)();
	int (*QS_Print)();
	int (*QS_Init)();
};


// vtables defines
struct QuickSort_vtable QuickSort_vtable_ ;
struct QS_vtable QS_vtable_ ;

// methods
void * frame_prev;

struct QS_Start_gc_frame{
	void * frame_prev;
	int * arguments_base_address;
	char * arguments_gc_map;
	char * locals_gc_map;
	struct QS * x_1;
	struct QS * x_2;
	struct QS * x_3;
	struct QS * x_4;
};

int QS_Start(struct QS * this, int sz)
{
	int aux01;
	int x_7;
	int x_8;
	int x_9;
	int x_10;
	int x_11;

	char * QS_Start_arguments_gc_map = "10";
	char * QS_Start_locals_gc_map = "1111";
	//put the GC stack frame onto the call stack.
	struct QS_Start_gc_frame frame;
	//push this frame onto the GC stack by setting up "prev".
	frame.frame_prev = frame_prev;
	frame_prev = &frame;
	//setting up memory GC maps and corresponding base addresses
	frame.arguments_gc_map = QS_Start_arguments_gc_map;
	frame.arguments_base_address = (int *)&this;
	frame.locals_gc_map = QS_Start_locals_gc_map;

L_0:


	x_7 = this->vptr->QS_Init(this, sz);
	x_8 = this->vptr->QS_Print(this);
	System_out_println (9999);

	x_9 = this->size - 1;
	aux01 = x_9;
	x_10 = this->vptr->QS_Sort(this, 0, aux01);
	x_11 = this->vptr->QS_Print(this);
	frame_prev = frame.frame_prev;
	return 0;
}

struct QS_Sort_gc_frame{
	void * frame_prev;
	int * arguments_base_address;
	char * arguments_gc_map;
	char * locals_gc_map;
	struct QS * x_5;
	struct QS * x_6;
};

int QS_Sort(struct QS * this, int left, int right)
{
	int v;
	int i;
	int j;
	int nt;
	int t;
	int cont01;
	int cont02;
	int aux03;
	int x_12;
	int x_13;
	int x_14;
	int x_15;
	int x_16;
	int x_17;
	int x_18;
	int x_19;
	int x_20;
	int x_21;
	int x_22;
	int x_23;

	char * QS_Sort_arguments_gc_map = "100";
	char * QS_Sort_locals_gc_map = "11";
	//put the GC stack frame onto the call stack.
	struct QS_Sort_gc_frame frame;
	//push this frame onto the GC stack by setting up "prev".
	frame.frame_prev = frame_prev;
	frame_prev = &frame;
	//setting up memory GC maps and corresponding base addresses
	frame.arguments_gc_map = QS_Sort_arguments_gc_map;
	frame.arguments_base_address = (int *)&this;
	frame.locals_gc_map = QS_Sort_locals_gc_map;

L_1:



	t = 0;
	x_12 = left < right;
	if (x_12)
	  goto L_2;
	else
	  goto L_3;
L_2:
	v = (this->number + 4)[right];
	x_13 = left - 1;
	i = x_13;
	j = right;
	cont01 = 1;
	goto L_7;
L_7:
	if (cont01)
	  goto L_5;
	else
	  goto L_6;
L_5:
	cont02 = 1;
	goto L_10;
L_10:
	if (cont02)
	  goto L_8;
	else
	  goto L_9;
L_8:
	x_14 = i + 1;
	i = x_14;
	aux03 = (this->number + 4)[i];
	x_15 = aux03 < v;
	if (!x_15)
	  goto L_11;
	else
	  goto L_12;
L_11:
	cont02 = 0;
	goto L_13;
L_12:
	cont02 = 1;
	goto L_13;
L_13:
	goto L_10;
L_9:
	cont02 = 1;
	goto L_16;
L_16:
	if (cont02)
	  goto L_14;
	else
	  goto L_15;
L_14:
	x_16 = j - 1;
	j = x_16;
	aux03 = (this->number + 4)[j];
	x_17 = v < aux03;
	if (!x_17)
	  goto L_17;
	else
	  goto L_18;
L_17:
	cont02 = 0;
	goto L_19;
L_18:
	cont02 = 1;
	goto L_19;
L_19:
	goto L_16;
L_15:
	t = (this->number + 4)[i];
	(this->number + 4)[i] = (this->number + 4)[j];
	(this->number + 4)[j] = t;
	x_19 = i + 1;
	x_18 = j < x_19;
	if (x_18)
	  goto L_20;
	else
	  goto L_21;
L_20:
	cont01 = 0;
	goto L_22;
L_21:
	cont01 = 1;
	goto L_22;
L_22:
	goto L_7;
L_6:
	(this->number + 4)[j] = (this->number + 4)[i];
	(this->number + 4)[i] = (this->number + 4)[right];
	(this->number + 4)[right] = t;
	x_21 = i - 1;
	x_20 = this->vptr->QS_Sort(this, left, x_21);
	x_23 = i + 1;
	x_22 = this->vptr->QS_Sort(this, x_23, right);
	goto L_4;
L_3:
	goto L_4;
L_4:
	frame_prev = frame.frame_prev;
	return 0;
}

struct QS_Print_gc_frame{
	void * frame_prev;
	int * arguments_base_address;
	char * arguments_gc_map;
	char * locals_gc_map;
};

int QS_Print(struct QS * this)
{
	int j;
	int x_24;
	int x_25;

	char * QS_Print_arguments_gc_map = "1";
	char * QS_Print_locals_gc_map = "";
	//put the GC stack frame onto the call stack.
	struct QS_Print_gc_frame frame;
	//push this frame onto the GC stack by setting up "prev".
	frame.frame_prev = frame_prev;
	frame_prev = &frame;
	//setting up memory GC maps and corresponding base addresses
	frame.arguments_gc_map = QS_Print_arguments_gc_map;
	frame.arguments_base_address = (int *)&this;
	frame.locals_gc_map = QS_Print_locals_gc_map;

L_23:
	j = 0;
	goto L_26;
L_26:
	x_24 = j < this->size;
	if (x_24)
	  goto L_24;
	else
	  goto L_25;
L_24:
	System_out_println ((this->number + 4)[j]);

	x_25 = j + 1;
	j = x_25;
	goto L_26;
L_25:
	frame_prev = frame.frame_prev;
	return 0;
}

struct QS_Init_gc_frame{
	void * frame_prev;
	int * arguments_base_address;
	char * arguments_gc_map;
	char * locals_gc_map;
	int * x_26;
};

int QS_Init(struct QS * this, int sz)
{
	int * x_26;

	char * QS_Init_arguments_gc_map = "10";
	char * QS_Init_locals_gc_map = "1";
	//put the GC stack frame onto the call stack.
	struct QS_Init_gc_frame frame;
	//push this frame onto the GC stack by setting up "prev".
	frame.frame_prev = frame_prev;
	frame_prev = &frame;
	//setting up memory GC maps and corresponding base addresses
	frame.arguments_gc_map = QS_Init_arguments_gc_map;
	frame.arguments_base_address = (int *)&this;
	frame.locals_gc_map = QS_Init_locals_gc_map;

L_27:

	this->size = sz;
	x_26 = (int *)Tiger_new_array(sizeof(int) * sz);
	this->number = x_26;
	(this->number + 4)[0] = 20;
	(this->number + 4)[1] = 7;
	(this->number + 4)[2] = 12;
	(this->number + 4)[3] = 18;
	(this->number + 4)[4] = 2;
	(this->number + 4)[5] = 11;
	(this->number + 4)[6] = 6;
	(this->number + 4)[7] = 9;
	(this->number + 4)[8] = 19;
	(this->number + 4)[9] = 5;
	frame_prev = frame.frame_prev;
	return 0;
}

// vtables
struct QuickSort_vtable QuickSort_vtable_ = 
{
	"",
};

struct QS_vtable QS_vtable_ = 
{
	"10",
	QS_Start,
	QS_Sort,
	QS_Print,
	QS_Init,
};


// main method

struct Tiger_main_gc_frame{
	void * frame_prev;
	int * arguments_base_address;
	char * arguments_gc_map;
	char * locals_gc_map;
	struct QS * x_0;
	struct QS * x_28;
};

int Tiger_main ()
{
	int x_27;
	char * tiger_main_arguments_gc_map = "";
	char * tiger_main_locals_gc_map = "11";
	//put the GC stack frame onto the call stack.
	struct Tiger_main_gc_frame frame;
	//push this frame onto the GC stack by setting up "prev".
	frame.frame_prev = frame_prev;
	frame_prev = &frame;
	//setting up memory GC maps and corresponding base addresses
	frame.arguments_gc_map = tiger_main_arguments_gc_map;
	frame.locals_gc_map = tiger_main_locals_gc_map;

L_28:
	frame.x_28 = ((struct QS*)(Tiger_new (&QS_vtable_, sizeof(struct QS))));
	x_27 = frame.x_28->vptr->QS_Start(frame.x_28, 10);
	System_out_println (x_27);

	frame_prev = frame.frame_prev;
	return 0;
}




