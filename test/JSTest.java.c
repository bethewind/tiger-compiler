// This is automatically generated by the Tiger compiler.
// Do NOT modify!

// Control-flow Graph

// structures
struct Test
{
	struct Test_vtable *vptr;
	int isObjOrArray;
	unsigned length;
	void * forwarding;
};
struct A
{
	struct A_vtable *vptr;
	int isObjOrArray;
	unsigned length;
	void * forwarding;
	int a;
};
struct B
{
	struct B_vtable *vptr;
	int isObjOrArray;
	unsigned length;
	void * forwarding;
	int a;
	int b;
};
// vtables structures
struct Test_vtable
{
	char * Test_gc_map;
};

struct A_vtable
{
	char * A_gc_map;
	int (*A_getA)();
};

struct B_vtable
{
	char * B_gc_map;
	int (*A_getA)();
	int (*B_getB)();
};


// vtables defines
struct Test_vtable Test_vtable_ ;
struct A_vtable A_vtable_ ;
struct B_vtable B_vtable_ ;

// methods
void * frame_prev;

struct A_getA_gc_frame{
	void * frame_prev;
	int * arguments_base_address;
	char * arguments_gc_map;
	char * locals_gc_map;
	struct B * bb;
	struct A * aa;
	struct B * x_1;
};

int A_getA(struct A * this)
{

	char * A_getA_arguments_gc_map = "1";
	char * A_getA_locals_gc_map = "111";
	//put the GC stack frame onto the call stack.
	struct A_getA_gc_frame frame;
	//push this frame onto the GC stack by setting up "prev".
	frame.frame_prev = frame_prev;
	frame_prev = &frame;
	//setting up memory GC maps and corresponding base addresses
	frame.arguments_gc_map = A_getA_arguments_gc_map;
	frame.arguments_base_address = (int *)&this;
	frame.locals_gc_map = A_getA_locals_gc_map;

L_0:
	frame.x_1 = ((struct B*)(Tiger_new (&B_vtable_, sizeof(struct B))));
	frame_prev = frame.frame_prev;
	return this->a;
}

struct B_getA_gc_frame{
	void * frame_prev;
	int * arguments_base_address;
	char * arguments_gc_map;
	char * locals_gc_map;
	struct B * bb;
	struct A * aa;
	struct B * x_2;
};

int B_getA(struct B * this)
{

	char * B_getA_arguments_gc_map = "1";
	char * B_getA_locals_gc_map = "111";
	//put the GC stack frame onto the call stack.
	struct B_getA_gc_frame frame;
	//push this frame onto the GC stack by setting up "prev".
	frame.frame_prev = frame_prev;
	frame_prev = &frame;
	//setting up memory GC maps and corresponding base addresses
	frame.arguments_gc_map = B_getA_arguments_gc_map;
	frame.arguments_base_address = (int *)&this;
	frame.locals_gc_map = B_getA_locals_gc_map;

L_1:
	frame.x_2 = ((struct B*)(Tiger_new (&B_vtable_, sizeof(struct B))));
	frame_prev = frame.frame_prev;
	return this->a;
}

struct B_getB_gc_frame{
	void * frame_prev;
	int * arguments_base_address;
	char * arguments_gc_map;
	char * locals_gc_map;
};

int B_getB(struct B * this)
{
	int x_3;

	char * B_getB_arguments_gc_map = "1";
	char * B_getB_locals_gc_map = "";
	//put the GC stack frame onto the call stack.
	struct B_getB_gc_frame frame;
	//push this frame onto the GC stack by setting up "prev".
	frame.frame_prev = frame_prev;
	frame_prev = &frame;
	//setting up memory GC maps and corresponding base addresses
	frame.arguments_gc_map = B_getB_arguments_gc_map;
	frame.arguments_base_address = (int *)&this;
	frame.locals_gc_map = B_getB_locals_gc_map;

L_2:
	x_3 = this->a + 100;
	frame_prev = frame.frame_prev;
	return x_3;
}

// vtables
struct Test_vtable Test_vtable_ = 
{
	"",
};

struct A_vtable A_vtable_ = 
{
	"0",
	A_getA,
};

struct B_vtable B_vtable_ = 
{
	"00",
	A_getA,
	B_getB,
};


// main method

struct Tiger_main_gc_frame{
	void * frame_prev;
	int * arguments_base_address;
	char * arguments_gc_map;
	char * locals_gc_map;
	struct B * x_0;
	struct B * x_5;
};

int Tiger_main ()
{
	int x_4;
	char * tiger_main_arguments_gc_map = "";
	char * tiger_main_locals_gc_map = "11";
	//put the GC stack frame onto the call stack.
	struct Tiger_main_gc_frame frame;
	//push this frame onto the GC stack by setting up "prev".
	frame.frame_prev = frame_prev;
	frame_prev = &frame;
	//setting up memory GC maps and corresponding base addresses
	frame.arguments_gc_map = tiger_main_arguments_gc_map;
	frame.locals_gc_map = tiger_main_locals_gc_map;

L_3:
	frame.x_5 = ((struct B*)(Tiger_new (&B_vtable_, sizeof(struct B))));
	x_4 = frame.x_5->vptr->B_getA(frame.x_5);
	System_out_println (x_4);

	frame_prev = frame.frame_prev;
	return 0;
}




