// This is automatically generated by the Tiger compiler.
// Do NOT modify!

// Control-flow Graph

// structures
struct Factorial
{
	struct Factorial_vtable *vptr;
	int isObjOrArray;
	unsigned length;
	void * forwarding;
};
struct Fac
{
	struct Fac_vtable *vptr;
	int isObjOrArray;
	unsigned length;
	void * forwarding;
};
// vtables structures
struct Factorial_vtable
{
	char * Factorial_gc_map;
};

struct Fac_vtable
{
	char * Fac_gc_map;
	int (*Fac_ComputeFac)();
};


// vtables defines
struct Factorial_vtable Factorial_vtable_ ;
struct Fac_vtable Fac_vtable_ ;

// methods
void * frame_prev;

struct Fac_ComputeFac_gc_frame{
	void * frame_prev;
	int * arguments_base_address;
	char * arguments_gc_map;
	char * locals_gc_map;
	struct Fac * x_1;
};

int Fac_ComputeFac(struct Fac * this, int num)
{
	int num_aux;
	int x_2;
	int x_3;
	int x_4;
	int x_5;

	char * Fac_ComputeFac_arguments_gc_map = "10";
	char * Fac_ComputeFac_locals_gc_map = "1";
	//put the GC stack frame onto the call stack.
	struct Fac_ComputeFac_gc_frame frame;
	//push this frame onto the GC stack by setting up "prev".
	frame.frame_prev = frame_prev;
	frame_prev = &frame;
	//setting up memory GC maps and corresponding base addresses
	frame.arguments_gc_map = Fac_ComputeFac_arguments_gc_map;
	frame.arguments_base_address = (int *)&this;
	frame.locals_gc_map = Fac_ComputeFac_locals_gc_map;

L_0:


	x_2 = num < 1;
	if (x_2)
	  goto L_1;
	else
	  goto L_2;
L_1:
	num_aux = 1;
	goto L_3;
L_2:
	x_5 = num - 1;
	x_4 = this->vptr->Fac_ComputeFac(this, x_5);
	x_3 = num * x_4;
	num_aux = x_3;
	goto L_3;
L_3:
	frame_prev = frame.frame_prev;
	return num_aux;
}

// vtables
struct Factorial_vtable Factorial_vtable_ = 
{
	"",
};

struct Fac_vtable Fac_vtable_ = 
{
	"",
	Fac_ComputeFac,
};


// main method

struct Tiger_main_gc_frame{
	void * frame_prev;
	int * arguments_base_address;
	char * arguments_gc_map;
	char * locals_gc_map;
	struct Fac * x_0;
	struct Fac * x_7;
};

int Tiger_main ()
{
	int x_6;
	char * tiger_main_arguments_gc_map = "";
	char * tiger_main_locals_gc_map = "11";
	//put the GC stack frame onto the call stack.
	struct Tiger_main_gc_frame frame;
	//push this frame onto the GC stack by setting up "prev".
	frame.frame_prev = frame_prev;
	frame_prev = &frame;
	//setting up memory GC maps and corresponding base addresses
	frame.arguments_gc_map = tiger_main_arguments_gc_map;
	frame.locals_gc_map = tiger_main_locals_gc_map;

L_4:
	frame.x_7 = ((struct Fac*)(Tiger_new (&Fac_vtable_, sizeof(struct Fac))));
	x_6 = frame.x_7->vptr->Fac_ComputeFac(frame.x_7, 10);
	System_out_println (x_6);

	frame_prev = frame.frame_prev;
	return 0;
}




